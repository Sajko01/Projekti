


// async checkAndApplyCrisisForAllTasks(startDate: Date, endDate: Date): Promise<void> {
//   console.log(`ğŸ“… Checking crisis for all tasks from ${startDate} to ${endDate}`);

//   const tasks = await this.taskRepository.find({
//     where: {
//       startDate: LessThanOrEqual(endDate),
//       endDate: MoreThanOrEqual(startDate),
//     },
//     relations: ['assignedWorkers', 'assignedMachines'],
//     order: { priority: 'ASC' },
//   });

//   console.log(`ğŸ“‹ Found ${tasks.length} tasks in period`);

//   const plans = await this.crisisPlanRepository.find();
//   console.log(`ğŸ“Œ Found ${plans.length} crisis plans`);

//   for (const task of tasks) {
//     console.log(`\nğŸ” Processing Task ${task.id}: ${task.name}`);
//     let crisisTriggered = false;

//     for (const plan of plans) {
//       console.log(`  âš¡ Checking plan: ${plan.description} (${plan.triggerCondition})`);

//       // ğŸ”¹ Trigger: Nedostatak radnika
//       const workersMatch = plan.triggerCondition.match(/workers\s*<\s*(\d+)/i);
//       if (workersMatch) {
//         const minWorkers = parseInt(workersMatch[1], 10);
//         const availableWorkers = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//         console.log(`    ğŸ‘· Available workers: ${availableWorkers.length} | Threshold: < ${minWorkers}`);
//         if (availableWorkers.length < minWorkers) {
//           crisisTriggered = true;
//           console.log('    âš ï¸ Triggered by workers');
//         }
//       }

//       // ğŸ”¹ Trigger: Nedostatak maÅ¡ina
//       const machinesMatch = plan.triggerCondition.match(/machines\s*<\s*(\d+)/i);
//       if (machinesMatch) {
//         const minMachines = parseInt(machinesMatch[1], 10);
//         const availableMachines = await this.machineService.getAvailableMachines(task.startDate, task.endDate);
//         console.log(`    ğŸ¤– Available machines: ${availableMachines.length} | Threshold: < ${minMachines}`);
//         if (availableMachines.length < minMachines) {
//           crisisTriggered = true;
//           console.log('    âš ï¸ Triggered by machines');
//         }
//       }

//       // ğŸ”¹ Trigger: Nedovoljno budÅ¾eta
//       const budgetMatch = plan.triggerCondition.match(/budget\s*<\s*(\d+(\.\d+)?)/i);
//       if (budgetMatch) {
//         const threshold = parseFloat(budgetMatch[1]);
//         const budgetOk = await this.budgetService.checkBudget(task.requiredBudget);
//         console.log(`    ğŸ’° Budget check: ok=${budgetOk} | Threshold: < ${threshold} | Required: ${task.requiredBudget}`);
//         if (!budgetOk && task.requiredBudget > threshold) {
//           crisisTriggered = true;
//           console.log('    âš ï¸ Triggered by budget');
//         }
//       }

//       // ovde moÅ¾eÅ¡ dodati joÅ¡ trigger-a
//     }

//     if (crisisTriggered) {
//       this.logger.warn(`Crisis triggered for Task ${task.id}: applying plan...`);
//       await this.applyAdvancedCrisisAction(task, plans);
//       console.log(`âœ… Applied crisis plan for Task ${task.id}`);
//     } else {
//       console.log(`âœ… No crisis for Task ${task.id}`);
//     }
//   }

//   console.log(`âœ… Finished checking all tasks`);
// }
   











// private async applyAdvancedCrisisAction(task: Task, plans: CrisisPlan[]): Promise<void> {
//   // Redistribucija radnika
//   const availableWorkers = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//   if (availableWorkers.length < task.requiredWorkers) {
//     let deficit = task.requiredWorkers - availableWorkers.length;

//     // OdloÅ¾i zadatke sa niÅ¾im prioritetom kako bi oslobodio radnike
//     const otherTasks = await this.taskRepository.find({
//       where: { status: 'in-progress', priority: MoreThan(task.priority) },
//       relations: ['assignedWorkers'],
//     });

//     for (const t of otherTasks) {
//       if (deficit <= 0) break;

//       const freedWorkers = t.assignedWorkers.splice(0, deficit);
//       await this.taskRepository.save(t);

//       availableWorkers.push(...freedWorkers);
//       deficit -= freedWorkers.length;
//       this.logger.log(`Freed ${freedWorkers.length} workers from Task ${t.id} for higher priority task ${task.id}`);
//     }
//   }

//   // Ako i dalje nema dovoljno resursa, odloÅ¾i trenutni zadatak
//   if (availableWorkers.length < task.requiredWorkers) {
//     task.status = 'delayed';
//     this.logger.warn(`Task ${task.id} delayed due to insufficient workers`);
//   } else {
//     // Dodeli radnike i maÅ¡ine
//     task.assignedWorkers = availableWorkers.slice(0, task.requiredWorkers);
//     const availableMachines = await this.machineService.getAvailableMachines(task.startDate, task.endDate);
//     task.assignedMachines = availableMachines.slice(0, task.requiredMachines);
//     task.status = 'in-progress';
//   }

//   await this.taskRepository.save(task);

//   // TODO: implementirati ostale akcije (budÅ¾et, metode, notifikacije)
// }








// private async applyAdvancedCrisisAction(task: Task, plans: CrisisPlan[]): Promise<void> {
//   // Redistribucija radnika
//   const availableWorkers = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//   if (availableWorkers.length < task.requiredWorkers) {
//     let deficit = task.requiredWorkers - availableWorkers.length;

//     // OdloÅ¾i zadatke sa niÅ¾im prioritetom kako bi oslobodio radnike
//     const otherTasks = await this.taskRepository.find({
//       where: { status: 'in-progress', priority: MoreThan(task.priority) },
//       relations: ['assignedWorkers'],
//     });

//     for (const t of otherTasks) {
//       if (deficit <= 0) break;

//       const freedWorkers = t.assignedWorkers.splice(0, deficit);
//       await this.taskRepository.save(t);

//       availableWorkers.push(...freedWorkers);
//       deficit -= freedWorkers.length;
//       this.logger.log(`Freed ${freedWorkers.length} workers from Task ${t.id} for higher priority task ${task.id}`);
//     }
//   }

//   // Ako i dalje nema dovoljno resursa, odloÅ¾i trenutni zadatak
//   if (availableWorkers.length < task.requiredWorkers) {
//     task.status = 'delayed';
//     this.logger.warn(`Task ${task.id} delayed due to insufficient workers`);
//   } else {
//     // Dodeli radnike i maÅ¡ine
//     task.assignedWorkers = availableWorkers.slice(0, task.requiredWorkers);
//     const availableMachines = await this.machineService.getAvailableMachines(task.startDate, task.endDate);
//     task.assignedMachines = availableMachines.slice(0, task.requiredMachines);
//     task.status = 'in-progress';
//   }

//   await this.taskRepository.save(task);

//   // TODO: implementirati ostale akcije (budÅ¾et, metode, notifikacije)
// }






// private async applyCrisisAction(task: Task, action: string): Promise<void> {
//   console.log('ğŸ”” applyCrisisAction called');
//   console.log('Task:', task);
//   console.log('Action:', action);

//   // 1ï¸âƒ£ Odlaganje zadatka
//   if (action.includes('postpone')) {
//     task.status = 'delayed';
//     await this.taskRepository.save(task); // save umesto update
//     this.logger.log(`Task ${task.id} postponed due to crisis`);
//     console.log(`Task ${task.id} postponed`);
//   }

//   // 2ï¸âƒ£ Redistribucija radnika
//   if (action.includes('redistribute workers')) {
//     console.log('ğŸ‘· Trigger: redistribute workers');
//     const availableWorkers = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//     console.log('Available workers:', availableWorkers.map(w => w.id));

//     if (availableWorkers.length >= task.requiredWorkers) {
//       task.assignedWorkers = availableWorkers.slice(0, task.requiredWorkers);
//       console.log('Assigning workers:', task.assignedWorkers.map(w => w.id));

//       await this.taskRepository.save(task); // save automatski menja many-to-many relaciju
//       this.logger.log(`Workers for task ${task.id} redistributed`);
//     } else {
//       this.logger.warn(`Not enough workers to redistribute for task ${task.id}`);
//       task.status = 'delayed';
//       await this.taskRepository.save(task);
//       console.log(`Task ${task.id} delayed due to insufficient workers`);
//     }
//   }

//   // 3ï¸âƒ£ Redistribucija maÅ¡ina
//   if (action.includes('redistribute machines')) {
//     console.log('ğŸ¤– Trigger: redistribute machines');
//     const availableMachines = await this.machineService.getAvailableMachines(task.startDate, task.endDate);
//     console.log('Available machines:', availableMachines.map(m => m.id));

//     if (availableMachines.length >= task.requiredMachines) {
//       task.assignedMachines = availableMachines.slice(0, task.requiredMachines);
//       console.log('Assigning machines:', task.assignedMachines.map(m => m.id));

//       await this.taskRepository.save(task);
//       this.logger.log(`Machines for task ${task.id} redistributed`);
//     } else {
//       this.logger.warn(`Not enough machines to redistribute for task ${task.id}`);
//       task.status = 'delayed';
//       await this.taskRepository.save(task);
//       console.log(`Task ${task.id} delayed due to insufficient machines`);
//     }
//   }

//   // 4ï¸âƒ£ ObaveÅ¡tavanje menadÅ¾era / log
//   if (action.includes('notify')) {
//     this.logger.warn(`Notify manager: crisis action for task ${task.id}`);
//     console.log(`Notify manager for task ${task.id}`);
//     // Ovde moÅ¾eÅ¡ dodati email/slack notifikaciju
//   }

//   // 5ï¸âƒ£ Adjust budget (primer)
//   if (action.includes('adjust budget')) {
//     const budgetOk = await this.budgetService.checkBudget(task.requiredBudget);
//     console.log(`ğŸ’° Budget check: ok=${budgetOk} | required=${task.requiredBudget}`);

//     if (!budgetOk) {
//       task.status = 'delayed';
//       await this.taskRepository.save(task);
//       this.logger.log(`Task ${task.id} delayed due to insufficient budget`);
//       console.log(`Task ${task.id} delayed due to insufficient budget`);
//     }
//   }
// }










// async adaptPlanAutomatically(startDate: Date, endDate: Date) {
//   console.log(`ğŸ“¥ Starting adaptive plan for period: ${startDate} â†’ ${endDate}`);

//   // 1ï¸âƒ£ Proveri RCCP kapacitet
//   const rccpResult = await this.roughCutCapacityPlanning(startDate, endDate);
//   console.log(`ğŸ“Š RCCP result:`, rccpResult);

//   if (rccpResult.workerCapacityOk && rccpResult.machineCapacityOk) {
//     console.log(`âœ… Svi kapaciteti su zadovoljeni, plan je validan.`);
//     return { message: 'Svi kapaciteti su zadovoljeni, plan je validan.' };
//   }

//   // 2ï¸âƒ£ Dohvati sve zadatke u periodu, sortirane po prioritetu
//   const tasks = await this.taskRepository.find({
//     where: {
//       startDate: LessThanOrEqual(endDate),
//       endDate: MoreThanOrEqual(startDate),
//     },
//     order: { priority: 'ASC' },
//     relations: ['assignedWorkers', 'assignedMachines'],
//   });
//   console.log(`ğŸ“‹ Found ${tasks.length} tasks in the period`);

//   let remainingWorkerHours = rccpResult.totalAvailableWorkerHours;
//   let remainingMachineHours = rccpResult.totalAvailableMachineHours;
//   const adaptedTasks: Task[] = [];

//   for (const task of tasks) {
//     const start = new Date(task.startDate);
//     const end = new Date(task.endDate);
//     const taskDurationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);
//     const requiredWorkerHours = taskDurationHours * task.requiredWorkers;
//     const requiredMachineHours = taskDurationHours * task.requiredMachines;

//     console.log(`ğŸ” Task ${task.id} (${task.name}): duration ${taskDurationHours}h, workers ${task.requiredWorkers}, machines ${task.requiredMachines}`);
//     console.log(`   Required worker hours: ${requiredWorkerHours}, Required machine hours: ${requiredMachineHours}`);
//     console.log(`   Remaining worker hours: ${remainingWorkerHours}, Remaining machine hours: ${remainingMachineHours}`);

//     if (requiredWorkerHours > remainingWorkerHours || requiredMachineHours > remainingMachineHours) {
//       console.log(`   âš ï¸ Not enough capacity for Task ${task.id}`);
//       if (task.priority >= 3) {
//         task.status = 'delayed';
//         adaptedTasks.push(task);
//         console.log(`   â³ Delaying task due to low capacity (priority ${task.priority})`);
//       } else {
//         remainingWorkerHours -= requiredWorkerHours;
//         remainingMachineHours -= requiredMachineHours;
//         console.log(`   âœ… Retaining high priority task, remaining hours updated`);
//       }
//     } else {
//       remainingWorkerHours -= requiredWorkerHours;
//       remainingMachineHours -= requiredMachineHours;
//       console.log(`   âœ… Capacity sufficient, task retained`);
//     }
//   }

//   // 3ï¸âƒ£ SaÄuvaj izmene u bazi
//   if (adaptedTasks.length > 0) {
//     await this.taskRepository.save(adaptedTasks);
//     console.log(`ğŸ’¾ Saved ${adaptedTasks.length} adapted tasks to database`);
//   } else {
//     console.log(`ğŸ’¾ No tasks needed adaptation`);
//   }

//   // ğŸ”„ 4ï¸âƒ£ PokuÅ¡aj vratiti neke delayed zadatke ako je ostalo kapaciteta
//   const delayedTasks = await this.taskRepository.find({
//     where: { status: 'delayed' },
//     order: { priority: 'ASC' },
//   });

//   const reactivatedTasks: Task[] = [];
//   for (const task of delayedTasks) {
//     const start = new Date(task.startDate);
//     const end = new Date(task.endDate);
//     const taskDurationHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);
//     const requiredWorkerHours = taskDurationHours * task.requiredWorkers;
//     const requiredMachineHours = taskDurationHours * task.requiredMachines;

//     if (requiredWorkerHours <= remainingWorkerHours && requiredMachineHours <= remainingMachineHours) {
//       task.status = 'in-progress'; // vraÄ‡amo ga u plan
//       reactivatedTasks.push(task);
//       remainingWorkerHours -= requiredWorkerHours;
//       remainingMachineHours -= requiredMachineHours;
//       console.log(`ğŸ”„ Reactivated delayed task ${task.id} (${task.name})`);
//     }
//   }
//   if (reactivatedTasks.length > 0) {
//     await this.taskRepository.save(reactivatedTasks);
//     console.log(`ğŸ’¾ Reactivated ${reactivatedTasks.length} delayed tasks`);
//   }

//   // ğŸ“ 5ï¸âƒ£ Upisi dodelu u TaskAssignment za sve aktivne zadatke
//   for (const task of tasks.filter(t => t.status !== 'delayed')) {
//     for (const worker of task.assignedWorkers || []) {
//       await this.taskAssignmentService.createWorkerAssignment(
//         task,
//         worker,
//         new Date(task.startDate),
//         new Date(task.endDate),
//       );
//     }
//     for (const machine of task.assignedMachines || []) {
//       await this.taskAssignmentService.createMachineAssignment?.(
//         task,
//         machine,
//         new Date(task.startDate),
//         new Date(task.endDate),
//       );
//     }
//   }

//   console.log(`âœ… Adaptive plan finished. Remaining worker hours: ${remainingWorkerHours}, machine hours: ${remainingMachineHours}`);
//   console.log(`ğŸ“‹ Adapted tasks:`, adaptedTasks.map(t => ({ id: t.id, name: t.name, status: t.status })));

//   return {
//     message: 'Plan je adaptiran automatski.',
//     adaptedTasks,
//     reactivatedTasks,
//     remainingWorkerHours,
//     remainingMachineHours,
//   };
// }





// async scheduleTasks(): Promise<void> {
//   console.log('ğŸ“… Scheduling tasks...');

//   const tasks = await this.taskRepository.find({
//     where: { status: 'planned' },
//     order: { priority: 'ASC', startDate: 'ASC' }
//   });

//   for (const task of tasks) {
//     console.log(`\nğŸ” Processing Task ${task.id}: ${task.name}`);

//     //const availableWorkers: WorkerEntity[] = await this.workerService.getAvailableWorkers(start, end);


//    // const availableWorkers = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//     const availableWorkers: WorkerEntity[] = await this.workerService.getAvailableWorkers(task.startDate, task.endDate);
//     const availableMachines = await this.machineService.getAvailableMachines(task.startDate, task.endDate);

//     if (availableWorkers.length >= task.requiredWorkers && availableMachines.length >= task.requiredMachines) {
//       task.status = 'in-progress';
//       await this.taskRepository.save(task);

//       // Kreiramo TaskAssignments
//     for (let i = 0; i < task.requiredWorkers; i++) {
//   await this.taskAssignmentService.createWorkerAssignment(
//     task,
//     availableWorkers[i],
//     task.startDate,
//     task.endDate
//   );
// }

//     for (let i = 0; i < task.requiredMachines; i++) {
//   await this.taskAssignmentService.createMachineAssignment(
//     task,
//     availableMachines[i],
//     task.startDate,
//     task.endDate
//   );
// }

//       console.log(`âœ… Task ${task.id} scheduled`);
//     } else {
//       task.status = 'delayed';
//       await this.taskRepository.save(task);
//       console.warn(`âš ï¸ Task ${task.id} delayed`);
//     }
//   }

//   console.log('âœ… Finished scheduling tasks');
// }
// async scheduleTasks(): Promise<void> {
//   console.log('ğŸ“… Scheduling tasks...');

//   // 1ï¸âƒ£ Pokreni transakciju
//   const queryRunner = this.dataSource.createQueryRunner();
//   await queryRunner.connect();
//   await queryRunner.startTransaction();

//   try {
//     const tasks = await this.taskRepository.find({
//       where: { status: 'planned' },
//       order: { priority: 'ASC', startDate: 'ASC' },
//       relations: ['assignedWorkers', 'assignedMachines'], // vaÅ¾no da relations bude tu
//     });

//     for (const task of tasks) {
//       console.log(`\nğŸ” Processing Task ${task.id}: ${task.name}`);

//       const availableWorkers: WorkerEntity[] = await this.workerService.getAvailableWorkers(
//         task.startDate,
//         task.endDate
//       );
//       const availableMachines = await this.machineService.getAvailableMachines(
//         task.startDate,
//         task.endDate
//       );

//       if (
//         availableWorkers.length >= task.requiredWorkers &&
//         availableMachines.length >= task.requiredMachines
//       ) {
//         task.status = 'in-progress';
//         await queryRunner.manager.save(task);

//         // âœ… Kreiramo TaskAssignments za radnike, ali izbegavamo duplikate
//         for (let i = 0; i < task.requiredWorkers; i++) {
//           const worker = availableWorkers[i];

//           const existingAssignment = await this.taskAssignmentRepository.findOne({
//             where: {
//               task: { id: task.id },
//               worker: { id: worker.id },
//               startDate: LessThanOrEqual(task.endDate),
//               endDate: MoreThanOrEqual(task.startDate),
//             },
//           });

//           if (!existingAssignment) {
//             await this.taskAssignmentService.createWorkerAssignment(
//               task,
//               worker,
//               task.startDate,
//               task.endDate
//             );
//             console.log(`ğŸ‘·â€â™‚ï¸ Assigned Worker ${worker.id} to Task ${task.id}`);
//           } else {
//             console.log(`âš ï¸ Skipping duplicate worker assignment for Worker ${worker.id}`);
//           }
//         }

//         // âœ… Kreiramo TaskAssignments za maÅ¡ine, izbegavamo duplikate
//         for (let i = 0; i < task.requiredMachines; i++) {
//           const machine = availableMachines[i];

//           const existingMachineAssignment = await this.taskAssignmentRepository.findOne({
//             where: {
//               task: { id: task.id },
//               machine: { id: machine.id },
//               startDate: LessThanOrEqual(new Date(task.endDate)),
//               endDate: MoreThanOrEqual(new Date(task.startDate)),
//             },
//           });

//           if (!existingMachineAssignment) {
//             await this.taskAssignmentService.createMachineAssignment(
//               task,
//               machine,
//               task.startDate,
//               task.endDate
//             );
//             console.log(`ğŸ¤– Assigned Machine ${machine.id} to Task ${task.id}`);
//           } else {
//             console.log(`âš ï¸ Skipping duplicate machine assignment for Machine ${machine.id}`);
//           }
//         }

//         // âœ… AÅ¾uriraj assignedWorkers i assignedMachines
//         task.assignedWorkers = availableWorkers.slice(0, task.requiredWorkers);
//         task.assignedMachines = availableMachines.slice(0, task.requiredMachines);
//         await queryRunner.manager.save(task);

//         console.log(`âœ… Task ${task.id} scheduled`);
//       } else {
//         task.status = 'delayed';
//         await queryRunner.manager.save(task);
//         console.warn(`âš ï¸ Task ${task.id} delayed`);
//       }
//     }

//     // 2ï¸âƒ£ Commit ako je sve proÅ¡lo
//     await queryRunner.commitTransaction();
//     console.log('âœ… Finished scheduling tasks (transaction committed)');
//   } catch (error) {
//     console.error('âŒ Error during scheduling, rolling back...', error);
//     await queryRunner.rollbackTransaction();
//     throw error;
//   } finally {
//     await queryRunner.release();
//   }
// }
// async scheduleTasks(): Promise<void> {
//   console.log('ğŸ“… Scheduling tasks...');

//   // 1ï¸âƒ£ Pokreni transakciju
//   const queryRunner = this.dataSource.createQueryRunner();
//   await queryRunner.connect();
//   await queryRunner.startTransaction();

//   try {
//     const tasks = await this.taskRepository.find({
//       where: { status: 'planned' },
//       order: { priority: 'ASC', startDate: 'ASC' },
//       relations: ['assignedWorkers', 'assignedMachines'],
//     });

//     for (const task of tasks) {
//       console.log(`\nğŸ” Processing Task ${task.id}: ${task.name}`);

//       const taskStart = new Date(task.startDate);
//       const taskEnd = new Date(task.endDate);

//       const availableWorkers: WorkerEntity[] = await this.workerService.getAvailableWorkers(
//         taskStart,
//         taskEnd
//       );
//       const availableMachines = await this.machineService.getAvailableMachines(
//         taskStart,
//         taskEnd
//       );

//       if (
//         availableWorkers.length >= task.requiredWorkers &&
//         availableMachines.length >= task.requiredMachines
//       ) {
//         task.status = 'in-progress';
//         await queryRunner.manager.save(task);

//         // âœ… Kreiramo TaskAssignments za radnike, izbegavamo duplikate
//         for (let i = 0; i < task.requiredWorkers; i++) {
//           const worker = availableWorkers[i];

//           const existingAssignment = await this.taskAssignmentRepository.findOne({
//             where: {
//               task: { id: task.id },
//               worker: { id: worker.id },
//               startDate: LessThanOrEqual(taskEnd),
//               endDate: MoreThanOrEqual(taskStart),
//             },
//           });

//           if (!existingAssignment) {
//             await this.taskAssignmentService.createWorkerAssignment(
//               task,
//               worker,
//               taskStart,
//               taskEnd
//             );
//             console.log(`ğŸ‘·â€â™‚ï¸ Assigned Worker ${worker.id} to Task ${task.id}`);
//           } else {
//             console.log(`âš ï¸ Skipping duplicate worker assignment for Worker ${worker.id}`);
//           }
//         }

//         // âœ… Kreiramo TaskAssignments za maÅ¡ine, izbegavamo duplikate
//         for (let i = 0; i < task.requiredMachines; i++) {
//           const machine = availableMachines[i];

//           const existingMachineAssignment = await this.taskAssignmentRepository.findOne({
//             where: {
//               task: { id: task.id },
//               machine: { id: machine.id },
//               startDate: LessThanOrEqual(taskEnd),
//               endDate: MoreThanOrEqual(taskStart),
//             },
//           });

//           if (!existingMachineAssignment) {
//             await this.taskAssignmentService.createMachineAssignment(
//               task,
//               machine,
//               taskStart,
//               taskEnd
//             );
//             console.log(`ğŸ¤– Assigned Machine ${machine.id} to Task ${task.id}`);
//           } else {
//             console.log(`âš ï¸ Skipping duplicate machine assignment for Machine ${machine.id}`);
//           }
//         }

//         // âœ… AÅ¾uriraj relations
//         task.assignedWorkers = availableWorkers.slice(0, task.requiredWorkers);
//         task.assignedMachines = availableMachines.slice(0, task.requiredMachines);
//         await queryRunner.manager.save(task);

//         console.log(`âœ… Task ${task.id} scheduled`);
//       } else {
//         task.status = 'delayed';
//         await queryRunner.manager.save(task);
//         console.warn(`âš ï¸ Task ${task.id} delayed`);
//       }
//     }

//     // 2ï¸âƒ£ Commit ako je sve proÅ¡lo
//     await queryRunner.commitTransaction();
//     console.log('âœ… Finished scheduling tasks (transaction committed)');
//   } catch (error) {
//     console.error('âŒ Error during scheduling, rolling back...', error);
//     await queryRunner.rollbackTransaction();
//     throw error;
//   } finally {
//     await queryRunner.release();
//   }
// }






// // // async checkAndApplyCrisis(task: Task): Promise<void> {
// // //   console.log('âœ… Task data for crisis check:', task);

// // //   // Dohvati sve krizne planove
// // //   const plans = await this.crisisPlanRepository.find();
// // //   console.log('ğŸ“‹ Krizni planovi iz baze:', plans);

// // //   for (const plan of plans) {
// // //     console.log(`ğŸ” Proveravam plan: ${plan.triggerCondition}`);

// // //     // 1ï¸âƒ£ Trigger: Nedostatak radnika
// // //     const workersMatch = plan.triggerCondition.match(/workers\s*<\s*(\d+)/i);
// // //     if (workersMatch) {
// // //       const minWorkers = parseInt(workersMatch[1], 10);

// // //       const availableWorkers = await this.workerService.getAvailableWorkers(
// // //         task.startDate,
// // //         task.endDate,
// // //       );

// // //       console.log(`ğŸ‘· Dostupni radnici: ${availableWorkers.length} | Prag iz plana: < ${minWorkers}`);

// // //       if (availableWorkers.length < minWorkers) {
// // //         this.logger.warn(`âš ï¸ Crisis triggered: ${plan.description} (Workers < ${minWorkers})`);
// // //         await this.applyCrisisAction(task, plan.action);
// // //       }
// // //     }

// // //     // 2ï¸âƒ£ Trigger: Nedostatak maÅ¡ina
// // //     const machinesMatch = plan.triggerCondition.match(/machines\s*<\s*(\d+)/i);
// // //     if (machinesMatch) {
// // //       const minMachines = parseInt(machinesMatch[1], 10);

// // //       const availableMachines = await this.machineService.getAvailableMachines(
// // //         task.startDate,
// // //         task.endDate,
// // //       );

// // //       console.log(`ğŸ¤– Dostupne maÅ¡ine: ${availableMachines.length} | Prag iz plana: < ${minMachines}`);

// // //       if (availableMachines.length < minMachines) {
// // //         this.logger.warn(`âš ï¸ Crisis triggered: ${plan.description} (Machines < ${minMachines})`);
// // //         await this.applyCrisisAction(task, plan.action);
// // //       }
// // //     }

// // //     // 3ï¸âƒ£ Trigger: Nedovoljno budÅ¾eta
// // //     const budgetMatch = plan.triggerCondition.match(/budget\s*<\s*(\d+(\.\d+)?)/i);
// // //     if (budgetMatch) {
// // //       const threshold = parseFloat(budgetMatch[1]);
// // //       const budgetOk = await this.budgetService.checkBudget(task.requiredBudget);

// // //       console.log(`ğŸ’° Provera budÅ¾eta: ok=${budgetOk} | prag < ${threshold} | potrebno: ${task.requiredBudget}`);

// // //       if (!budgetOk && task.requiredBudget > threshold) {
// // //         this.logger.warn(`âš ï¸ Crisis triggered: ${plan.description} (Budget < ${threshold})`);
// // //         await this.applyCrisisAction(task, plan.action);
// // //       }
// // //     }

// // //     // 4ï¸âƒ£ Trigger: LoÅ¡ metod (efikasnost metode)
// // //     const methodMatch = plan.triggerCondition.match(/method\s*efficiency\s*<\s*(\d+(\.\d+)?)/i);
// // //     if (methodMatch) {
// // //       const threshold = parseFloat(methodMatch[1]);
// // //       console.log(`ğŸ“ Efikasnost metode: ${task.method?.efficiencyFactor} | prag < ${threshold}`);

// // //       if (task.method?.efficiencyFactor && task.method.efficiencyFactor < threshold) {
// // //         this.logger.warn(`âš ï¸ Crisis triggered: ${plan.description} (Method efficiency < ${threshold})`);
// // //         await this.applyCrisisAction(task, plan.action);
// // //       }
// // //     }

// // //     // 5ï¸âƒ£ Ovde moÅ¾eÅ¡ dodati druge/custom trigger-e po potrebi
// // //   }

// // //   console.log(`âœ… ZavrÅ¡ena provera kriznih planova za Task: ${task.id}`);
// // //   console.log(`âœ… Crisis check finished for Task ${task.id}`);
// // // }

